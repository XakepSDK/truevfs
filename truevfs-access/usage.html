<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <link href="./css/prettify.css" type="text/css" rel="stylesheet"/>
    <script src="./js/prettify.js" type="text/javascript"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>TrueVFS Access &#x2013; Using TrueVFS Access</title>
    <style type="text/css" media="all">
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print"/>
    <meta name="author" content="Christian Schlichtherle"/>
    <meta name="Date-Revision-yyyymmdd" content="20170919"/>
    <meta http-equiv="Content-Language" content="en"/>
          <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-25500668-1']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
                  <script>
        (function() {
          var cx = '003580521944097984334:8uinm6tpaz4';
          var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
          gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
              '//www.google.com/cse/cse.js?cx=' + cx;
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
        })();
      </script>
                                                          
<link title="The TrueZIP Blog - Announcements Feed" rel="alternate" type="application/rss+xml" href="http://truevfs.schlichtherle.de/category/announcements/feed/"/>
                      
  </head>
  <body class="composite" onload="prettyPrint()">
    <div id="banner">
                    <div id="bannerLeft">
                TrueVFS Access
                </div>
                                <div id="gcse-search-form" class="gcse-searchbox-only"></div>
            <div class="clear"><hr/></div>
    </div>
    <div id="breadcrumbs">
            
                                  <div class="xleft">
        <span id="projectVersion">Version: 0.12.0</span>
                  |                         <a href="../index.html" title="TrueVFS">TrueVFS</a>
      &raquo;
                            <a href="./" title="TrueVFS Access">TrueVFS Access</a>
      &raquo;
      TrueVFS Access &#x2013; Using TrueVFS Access
              </div>
            <div class="xright">        
                        </div>
      <div class="clear"><hr/></div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
              
                                                   <h5>Documentation</h5>
                  <ul>
                  <li class="none">
                          <a href="index.html" title="About">About</a>
            </li>
                  <li class="none">
            <strong>Usage</strong>
          </li>
                  <li class="none">
                          <a href="configuration.html" title="Configuration">Configuration</a>
            </li>
          </ul>
                       <h5>Parent Module</h5>
                  <ul>
                  <li class="none">
                          <a href="../index.html" title="TrueVFS">TrueVFS</a>
            </li>
          </ul>
                       <h5>Sub-Modules</h5>
                                 <h5>Reports</h5>
                  <ul>
                                                                                                                                                                                                                                                                          <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                      <li class="collapsed">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                  </li>
          </ul>
                     
<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
  <div class="paypalButton">
    <input name="cmd" value="_s-xclick" type="hidden"/>
    <input name="hosted_button_id" value="AGDEQWWKNZ6UL" type="hidden"/>
    <input style="border: 0" alt="PayPal - The safer, easier way to pay online!" name="submit" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" type="image"/>
  </div>
</form>
                                
                              </div>
    </div>
    <div id="bodyColumn" class="content">
      <div id="contentBox">
                                      <div class="section">
<h2><a name="Using_TrueVFS_Access"></a>Using TrueVFS Access</h2>
<div class="section">
<h3><a name="Abstract"></a>Abstract</h3>
<p>This article explains the usage of the module TrueVFS&#160;Access*.</p></div>
<div class="section">
<h3><a name="Basic_Operations"></a>Basic Operations</h3>
<p>In order to create a new archive file, an application can simply call <a href="../apidocs/net/java/truevfs/access/TFile.html#mkdir"><tt>TFile.mkdir()</tt></a>.</p>
<p>In order to delete it, an application can call <a href="../apidocs/net/java/truevfs/access/TFile.html#delete"><tt>TFile.delete()</tt></a>. Like a plain old directory, this is only possible if the archive file is empty. Unfortunately, this method can only return <tt>false</tt> on error, leaving you with no indication of failure. Alternatively, an application could call <a href="../apidocs/net/java/truevfs/access/TFile.html#rm"><tt>TFile.rm()</tt></a> or <a href="../apidocs/net/java/truevfs/access/TFile.html#rm_r"><tt>TFile.rm_r()</tt></a> in order to delete a file or an entire (virtual) directory tree respectively. These methods will fail with an <tt>IOException</tt>.</p>
<p>To read an archive <i>entry</i>, an application can simply create a <a href="../apidocs/net/java/truevfs/access/TFileInputStream.html"><tt>TFileInputStream</tt></a> or a <a href="../apidocs/net/java/truevfs/access/TFileReader.html"><tt>TFileReader</tt></a> object. Note that an application cannot use these classes to read a valid archive <i>file</i> itself.</p>
<p>Likewise, to write an archive <i>entry</i>, an application can simply create a <a href="../apidocs/net/java/truevfs/access/TFileOutputStream.html"><tt>TFileOutputStream</tt></a> or a <a href="../apidocs/net/java/truevfs/access/TFileWriter.html"><tt>TFileWriter</tt></a> object. Note that an application cannot use these classes to write a valid archive <i>file</i> itself.</p>
<p>If an application just needs to copy data however, using one of the <a href="../apidocs/net/java/truevfs/access/TFile.html#bulkIOMethods">copy methods</a> in the class <a href="../apidocs/net/java/truevfs/access/TFile.html"><tt>TFile</tt></a> is highly recommended instead of using <tt>TFile(In|Out)putStream</tt> or <tt>TFile(Reader|Writer)</tt> directly. These methods use pooled buffers and pooled threads and do not need to decompress/recompress archive entry data when copying from one archive file to another for supported archive types. In addition, they are guaranteed to close their streams if an <tt>IOException</tt> occurs.</p>
<p>Note that there is no eqivalent to <tt>RandomAccessFile</tt> in this package because it's impossible to seek within compressed archive entry data.</p>
<div class="section">
<h4><a name="Properly_Closing_Archive_Entry_Streams"></a>Properly Closing Archive Entry Streams</h4>
<p>In general, when using streams, an application should always close them in a <tt>finally</tt>-block or use a try-with-resources statement like this:</p>
<div class="source">
<pre>try (InputStream in = new TFileInputStream(path)) {
    TFile.cat(in, System.out);
}
</pre></div>
<p>This ensures that the stream is closed even if an exception occurs.</p>
<p>Note that the <tt>OutputStream.close()</tt> method may throw an <tt>IOException</tt>, too. Applications need to deal with this appropriately, for example by enclosing the entire block within another <tt>try-catch</tt>-block:</p>
<div class="source">
<pre>try (InputStream in = new TFileInputStream(path)) {
    TFile.cat(in, System.out);
} catch (IOException ouch) {
    ouch.printStackTrace();
}
</pre></div>
<p>This idiom is not at all specific to TrueVFS: Streams often utilize OS resources such as file descriptors or network connections. All OS resources are limited however and sometimes they are even exclusively allocated for a stream, so the stream should always be closed as soon as possible again, especially in long running server applications - relying on <tt>Object.finalize()</tt> to do this during garbage collection is unsafe.</p>
<p>TrueVFS is affected by open archive entry streams in the following way: When unmounting an archive file (see <a href="#Committing_Unsynchronized_Changes_To_The_Contents_Of_Archive_Files">below</a>), depending on the parameters, TrueVFS may choose to force the closing of any open entry streams or not. If the entry streams are <i>not</i> forced to close, the archive file cannot get unmounted and ab <a href="../apidocs/net/java/truevfs/kernel/spec/FsSyncException.html"><tt>FsSyncException</tt></a> is thrown. If the entry streams are forced to close however, the archive file is unmounted and an <a href="../apidocs/net/java/truevfs/kernel/spec/FsSyncWarningException.html"><tt>FsSyncWarningException</tt></a> is thrown to indicate that any subsequent I/O operations on these entry streams other than <tt>(In|Out)putStream.close()</tt> will fail with a <tt>net.java.truecommons.io.Closed(In|Out)putException</tt> respectively.</p>
<p>In order to prevent these exceptions, TrueVFS automatically closes entry streams when they are garbage collected. However, an application should not rely on this because the delay and order in which streams are processed by the finalizer thread is not specified and any data buffered by an output stream gets lost.</p></div></div>
<div class="section">
<h3><a name="Committing_Unsynchronized_Changes_To_The_Contents_Of_Archive_Files"></a>Committing Unsynchronized Changes To The Contents Of Archive Files</h3>
<p>To provide random read/write access to archive files, TrueVFS needs to associate some state for every accessed archive file on the heap and in some temporary files while the application is operating on its federated file system.</p>
<p>TrueVFS automatically <i>mounts</i> the federated file system from an archive file on the first read or write access. The application can then operate on the federated file system in arbitrary manner. Finally, an archive file must get <i>unmounted</i> in order to commit any unsynchronized changes to its contents or meta data.</p>
<div class="section">
<h4><a name="Manual_Versus_Automatic_Synchronization"></a>Manual Versus Automatic Synchronization</h4>
<p>Archive file synchronization is performed semi-automatic:</p>
<ul>
<li><i>Manual synchronization</i> happens when the application calls <a href="../apidocs/net/java/truevfs/access/TVFS.html#umount"><tt>TVFS.umount()</tt></a>, which calls <a href="../apidocs/net/java/truevfs/access/TVFS.html#syncnet.truevfs.kernel.util.BitField"><tt>TVFS.sync(BitField&lt;FsSyncOption&gt;)</tt></a>, or any of their many variants and incarnations.</li>
<li><i>Automatic synchronization</i> happens when the JVM terminates (in a JVM shutdown hook) or when the application modifies an archive entry more than once and <tt>FsOutputOption.GROW</tt> hasn't been set or isn't supported by the respective archive driver.</li></ul>
<p>Manual synchronization is required to support third-party access to an archive file (see <a href="#Third_Party_Access">below</a>). It also enables some control over any exceptions thrown: <tt>TVFS.umount()</tt> or <tt>TVFS.sync(BitField&lt;FsSyncOption&gt;)</tt> may throw an <a href="../apidocs/net/java/truevfs/kernel/FsSyncException.html"><tt>FsSyncException</tt></a>. An application may catch these exceptions and act on them individually (see <a href="#Exception_Handling">below</a>).</p>
<p>However, calling <tt>TVFS.sync(BitField&lt;FsSyncOption&gt;)</tt> too often may increase the overall runtime: With the full update strategy, if an application is manually synchronizing a mounted archive file after each modification, then this results in an overall runtime of <tt>O(s*s)</tt>, where <tt>s</tt> is the size of the target archive file in bytes (see <a href="#Performance_Considerations">below</a>).</p>
<p>In general, avoiding manual synchronization provides best performance because automatic synchronization only happens if there's really a need to. It also works reliably because it's run in a JVM shutdown hook, too, which is always run unless the JVM crashes (note that an uncatched <tt>Throwable</tt> <i>terminates</i> the JVM, but does not <i>crash</i> it).</p>
<p>The disadvantage is that you cannot easily catch and deal with any exceptions thrown as a result of an automatic synchronization because it may happen on any write operation in a file system controller. If it happens within the JVM shutdown hook, you can't even catch the exception. It's stack trace is printed to standard error output instead.</p>
<p>In addition, synchronizing an existing archive file takes linear runtime (see <a href="#Performance_Considerations">below</a>). However, using long running JVM shutdown hooks to perform an update to a large archive file is generally discouraged.</p></div>
<div class="section">
<h4><a name="Third_Party_Access"></a>Third Party Access</h4>
<p>Whenever a TrueVFS application accesses an archive file for reading or writing, the TrueVFS Kernel associates some state on the heap with it. This archive file is then said to be <i>mounted</i>. The TrueVFS Kernel manages the associated state until the archive file gets <i>unmounted</i> again, e.g. by a call to <a href="../apidocs/net/java/truevfs/access/TVFS.html#umount"><tt>TVFS.umount()</tt></a>.</p>
<p>Due to this strategy, the TrueVFS Kernel assumes exclusive access to any mounted archive files. <b>THIRD PARTIES MUST NOT CONCURRENTLY ACCESS MOUNTED ARCHIVE FILES!</b> In this context, third parties are:</p>
<ol style="list-style-type: decimal">
<li>Instances of the class <a href="../apidocs/net/java/truevfs/access/TFile.html"><tt>TFile</tt></a> which do not detect the same set of archive files in a path name due to the use of a differently configured <a href="../apidocs/net/java/truevfs/access/TArchiveDetector.html"><tt>TArchiveDetector</tt></a>.</li>
<li>Instances of the class <tt>File</tt> which are not instances of the class <tt>TFile</tt>.</li>
<li>Any TrueVFS classes which have been defined by a different class loader.</li>
<li>Any other operating system processes.</li></ol>
<p><b>FAILURE TO COMPLY TO THESE CONSTRAINTS MAY RESULT IN UNPREDICTABLE BEHAVIOR AND EVEN CAUSE LOSS OF DATA!</b></p>
<p>As a rule of thumb, to ensure that all <tt>TFile</tt> objects recognize the same set of archive files in path names, it's recommended to avoid using constructors or methods of the <tt>TFile</tt> class with an explicit <tt>TArchiveDetector</tt> parameter.</p>
<p>If these restrictions cannot be respected for some reason, an application may call <tt>TVFS.umount()</tt>, <a href="../apidocs/net/java/truevfs/access/TVFS.html#umountnet.truevfs.file.TFile"><tt>TVFS.umount(TFile)</tt></a> or any of their many variants and incarnations (e.g. <a href="../apidocs/net/java/truevfs/access/TVFS.html#syncnet.truevfs.kernel.FsSyncOption"><tt>TVFS.sync(BitField&lt;FsSyncOption&gt;)</tt></a>). in order to commit all changes and finally unmount the archive files. A third party can then safely access them. Likewise, the application must make sure not to access an archive file or any of its entries while the third party is accessing it.</p></div>
<div class="section">
<h4><a name="Exception_Handling"></a>Exception Handling</h4>
<p><a href="../apidocs/net/java/truevfs/access/TVFS.html#umount"><tt>TVFS.umount()</tt></a> and <a href="../apidocs/net/java/truevfs/access/TVFS.html#syncnet.truevfs.kernel.option.SyncOption"><tt>TVFS.sync(SyncOption...)</tt></a> process <i>all</i> archive files which are currently mounted. However, an <tt>IOException</tt> may occur for each archive file. Hence, the TrueVFS Kernel assembles all I/O exceptions which occur during the processing into a single I/O exception by using a <tt>net.java.truecommons.shed.PriorityExceptionBuilder</tt>. The priority exception builder suppresses all but the first input exception with the highest priority by using <i>exception suppressing</i>, which is a new feature in JSE&#160;7 (see <tt>Throwable.addSuppressed(Throwable)</tt>).</p>
<p>Catching and dealing with such an I/O exception is easy - just apply the standard idioms for exception handling:</p>
<div class="source">
<pre>try {
    TVFS.umount();
} catch (FsSyncException ouch) {
    // This exception may have several suppressed exceptions for
    // different archive files.
    ouch.printStackTrace();
}
</pre></div>
<p>The priority of a file system sync exception is obtained by calling <a href="../apidocs/net/java/truevfs/kernel/FsSyncException.html#getPriority"><tt>FsSyncException.getPriority()</tt></a>:</p>
<ol style="list-style-type: decimal">
<li>The class <a href="../apidocs/net/java/truevfs/kernel/FsSyncException.html"><tt>FsSyncException</tt></a> is the root of the file system sync exception class hierarchy. An exception of this type gets thrown if an archive file could not get updated and some or all of its data got lost. Its priority is <tt>0</tt>.</li>
<li>The class <a href="../apidocs/net/java/truevfs/kernel/FsSyncWarningException.html"><tt>FsSyncWarningException</tt></a> is used to indicate warning conditions. An exception of this type gets thrown if an archive file has been synchronized without loss of data, but some warning conditions apply. Its priority is <tt>-10</tt>.</li></ol>
<p>This strategy enables applications to selectively catch and filter file system sync exceptions according to the following standard idiom:</p>
<div class="source">
<pre>try {
    TVFS.umount();
} catch (FsSyncWarningException oops) {
    // Only objects of the class FsSyncWarningException may be
    // suppressed in this exception - we ignore this.
} catch (FsSyncException ouch) {
    // At least one exception occured which is not just an
    // FsSyncWarningException.
    // This indicates loss of data and needs to get handled.
    ouch.printStackTrace();
}
</pre></div></div>
<div class="section">
<h4><a name="Performance_Considerations"></a>Performance Considerations</h4>
<p>Synchronizing a mounted archive file is a linear runtime operation: If the size of the target archive file is <tt>s</tt> bytes, the operation always completes in <tt>O(s)</tt>, even if only a single, small archive entry has been modified within a very large archive file. Unmounting an unmodified or newly created archive file is a constant time operation, i.e. it completes in <tt>O(1)</tt>. Note that the complexity is independent of whether synchronization was performed manually or automatically.</p>
<p>Now if an application modifies each entry in a loop and accidentally triggers synchronizing the archive file on each iteration, then the overall runtime increases to <tt>O(s*s)</tt>! Here's an example:</p>
<div class="source">
<pre>String[] names = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
int n = names.length;
for (int i = 0; i &lt; n; i++) { // n * ...
    TFile entry = new TFile(&quot;archive.zip&quot;, names[i]); // O(1)
    entry.createNewFile(); // O(1)
    TVFS.umount(); // O(i + 1) !!
}
// Overall: O(n * n) !!!
</pre></div>
<p>The bad run-time performance is because <tt>File.umount()</tt> is called within the loop. Moving it out of the loop fixes the issue:</p>
<div class="source">
<pre>String[] names = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
int n = names.length;
for (int i = 0; i &lt; n; i++) { // n * ...
    TFile entry = new TFile(&quot;archive.zip&quot;, names[i]); // O(1)
    entry.createNewFile(); // O(1)
}
TVFS.umount(); // new file: O(1); modified: O(n)
// Overall: O(n)
</pre></div>
<p>In essence: If at all, an application should never call <a href="../apidocs/net/java/truevfs/access/TVFS.html#umount"><tt>TVFS.umount()</tt></a> or <a href="../apidocs/net/java/truevfs/access/TVFS.html#syncnet.truevfs.kernel.util.BitField"><tt>TVFS.sync(BitField)</tt></a> in a loop which modifies an archive file.</p>
<p>The situation gets more complicated with implicit remounting: If a file entry shall get modified which already has been modified before, TrueVFS implicitly remounts the archive file in order to avoid writing duplicated entries to it (which would waste space and may even confuse other utilities). Here's an example:</p>
<div class="source">
<pre>String[] names = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; };
int n = names.length;
for (int i = 0; i &lt; n; i++) { // n * ...
    TFile entry = new TFile(&quot;archive.zip&quot;, names[i]); // O(1)
    entry.createNewFile(); // First modification: O(1)
    entry.createNewFile(); // Second modification triggers remount: O(i + 1) !!
}
// Overall: O(n * n) !!!
</pre></div>
<p>Each call to <a href="../apidocs/net/java/truevfs/access/TFile.html#createNewFile"><tt>TFile.createNewFile()</tt></a> is a modification operation. Hence, on the second call to this method, TrueVFS needs to do an automatic synchronization which writes all entries in the archive file created so far to its parent file system again.</p>
<p>Unfortunately, a modification operation is not always so easy to spot. Consider the following example to create an archive file with empty entries which all share the same last modification time:</p>
<div class="source">
<pre>long time = System.currentTimeMillis();
String[] names = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; };
int n = names.length;
for (int i = 0; i &lt; n; i++) { // n * ...
    TFile entry = new TFile(&quot;archive.zip&quot;, names[i]); // O(1)
    entry.createNewFile(); // First modification: O(1)
    entry.setLastModified(time); // Second modification triggers remount: O(i + 1) !!
}
// Overall: O(n * n) !!!
</pre></div>
<p>When <a href="../apidocs/net/java/truevfs/access/TFile.html#setLastModifiedlong"><tt>TFile.setLastModified(long)</tt></a> gets called, the entry has already been written and so an implicit remount is triggered, which writes all entries in the archive file created so far to disk again.</p>
<p><b>Detail:</b> This deficiency is caused by archive file formats: All currently supported archive types require to write an entry's meta data (including the last modification time) before its content to the archive file. So if the meta data is to be modified, the archive entry and hence the whole archive file needs to get rewritten, which is what the automatic synchronization is doing.</p>
<p>To avoid accidental synchronization when copying data, please consider using the advanced <a href="../apidocs/net/java/truevfs/access/TFile.html#CopyMethods">copy methods</a> instead. These methods are easy to use and provide best performance.</p></div>
<div class="section">
<h4><a name="Conclusions"></a>Conclusions</h4>
<p>Here are some guidelines to find the right balance between performance and control:</p>
<ol style="list-style-type: decimal">
<li>When the JVM terminates, calling <a href="../apidocs/net/java/truevfs/access/TVFS.html#umount"><tt>TVFS.umount()</tt></a> or <a href="../apidocs/net/java/truevfs/access/TVFS.html#syncnet.truevfs.kernel.util.BitField"><tt>TVFS.sync(BitField)</tt></a> is recommended in order to handle exceptions explicitly.</li>
<li>Otherwise, in order to achieve best performance, <a href="../apidocs/net/java/truevfs/access/TVFS.html#umount"><tt>TVFS.umount()</tt></a> or <a href="../apidocs/net/java/truevfs/access/TVFS.html#syncnet.truevfs.kernel.util.BitField"><tt>TVFS.sync(BitField)</tt></a> should not get called unless either third party access or explicit exception handling is required.</li>
<li>For the same reason, these methods should <b>never</b> get called in a loop which modifies the contents of an archive file.</li></ol></div></div>
<div class="section">
<h3><a name="Atomicity_of_File_System_Operations"></a>Atomicity of File System Operations</h3>
<p>In general, a file system operation is either atomic or not. In its strict sense, an atomic operation meets the following conditions:</p>
<ol style="list-style-type: decimal">
<li>The operation either completely succeeds or completely fails. If it fails, the state of the file system is not changed.</li>
<li><a href="#Third_Party_Access">Third parties</a> can't monitor or influence the changes as they are in progress - they can only observe the result.</li></ol>
<p>All reliable file system implementations meet the first condition and so does TrueVFS. However, the situation is different for the second condition:</p>
<ul>
<li>TrueVFS's virtual file system implementation is running in a JVM process, so other processes could monitor or influence changes in progress.</li>
<li>TrueVFS's recognition of archive files is configurable, so other <tt>File</tt> instances could monitor or influence changes in progress.</li>
<li>TrueVFS maintains state information about archive files on the heap and in temporary files, so other definitions of the classes in this package which have been loaded by other class loaders could monitor or influence changes in progress.</li></ul>
<p>This implies that TrueVFS cannot provide any operations which are atomic in its strict sense. However, many file system operations in this package are declared to be virtually atomic according to their Javadoc. A virtually atomic operation meets the following conditions:</p>
<ol style="list-style-type: decimal">
<li>The operation either completely succeeds or completely fails. If it fails, the state of the (virtual) file system is not changed.</li>
<li>If the path does not contain any archive files, the operation is always delegated to the real file system and third parties can't monitor or influence the changes as they are in progress - they can only observe the result.</li>
<li>Otherwise, all <a href="../apidocs/net/java/truevfs/access/TFile.html"><tt>TFile</tt></a> instances which recognize the same set of archive file types and are defined by the same class loader can't monitor or influence the changes as they are in progress - they can only observe the result.</li></ol>
<p>These conditions apply regardless of whether the <a href="../apidocs/net/java/truevfs/access/TFile.html"><tt>TFile</tt></a> instances are used by different threads or not. In other words, TrueVFS is thread safe as much as you could expect from a platform file system.</p></div>
<div class="section">
<h3><a name="Miscellaneous"></a>Miscellaneous</h3>
<div class="section">
<h4><a name="Virtual_Directories_within_Archive_Files"></a>Virtual Directories within Archive Files</h4>
<p>The top level entries in an archive file populate its virtual root directory. The root directory is never written to the output when an archive file is modified.</p>
<p>For an application, the root directory behaves like any other directory and is addressed by naming the archive file in a path: For example, an application may list its contents by calling <a href="../apidocs/net/java/truevfs/access/TFile.html#list"><tt>TFile.list()</tt></a> or <a href="../apidocs/net/java/truevfs/access/TFile.html#listFiles"><tt>TFile.listFiles()</tt></a></p>
<p>An archive may contain directories for which no entry is present in the file although they contain at least one member in their directory tree for which an entry is actually present in the file. Similarly, if <a href="../apidocs/net/java/truevfs/access/TFile.html#isLenient"><tt>TFile.isLenient()</tt></a> returns <tt>true</tt> (which is the default), an archive entry may be created in an archive file although its parent directory hasn't been explicitly created by calling <a href="../apidocs/net/java/truevfs/access/TFile.html#mkdir"><tt>TFile.mkdir()</tt></a> before.</p>
<p>Such a directory is called a <i>ghost directory</i>: Like the root directory, a ghost directory is not written to the output whenever an archive file is modified. This is to mimic the behavior of most archive utilities which do not create archive entries for directories.</p>
<p>To the application, a ghost directory behaves like a regular directory with the exception that its last modification time returned by <a href="../apidocs/net/java/truevfs/access/TFile.html#lastModified"><tt>TFile.lastModified()</tt></a> is <tt>0L</tt>. If the application sets the last modification time explicitly using <a href="../apidocs/net/java/truevfs/access/TFile.html#setLastModifiedlong"><tt>TFile.setLastModified(long)</tt></a>, then the ghost directory reincarnates as a regular directory and will be output to the archive file.</p>
<p>Mind that a ghost directory can only exist within an archive file, but not every directory within an archive file is actually a ghost directory.</p></div>
<div class="section">
<h4><a name="Entry_Names_in_Archive_Files"></a>Entry Names in Archive Files</h4>
<p>File paths may be composed of elements which either refer to regular nodes in the real file system (directories, files or special files), including top level archive files, or refer to entries within an archive file.</p>
<p>As usual in Java, elements in a path which refer to regular nodes may be case sensitive or not in TrueVFS's VFS, depending on the real file system and/or the platform.</p>
<p>However, elements in a path which refer to archive entries are <i>always</i> case sensitive. This enables an application to address all files in existing archive files, regardless of the operating system they've been created on.</p>
<p>If an entry name contains characters which have no representation in the character set of the corresponding archive file type, then all file operations to create the archive entry will fail gracefully according to the documented contract of the respective operation. This is to protect an application from creating archive entries which cannot get encoded and decoded again correctly. For example, the Euro sign (&#x20ac;) does not have a representation in the IBM437 character set and hence cannot be used for entry names in ordinary ZIP files unless the ZIP file system driver's configuration is customized to use another character set.</p>
<p>If an archive file contains entries with absolute entry names, such as <tt>/readme.txt</tt> rather than <tt>readme.txt</tt>, the application cannot address these entries using the VFS in this package. However, these entries are retained like any other entry whenever the application modifies the archive file.</p>
<p>If an archive file contains both a file and a directory entry with the same name it's up to the individual methods how they behave in this case. This could happen with archive files created by external tools only. Both <a href="../apidocs/net/java/truevfs/access/TFile.html#isDirectory"><tt>TFile.isDirectory()</tt></a> and <a href="../apidocs/net/java/truevfs/access/TFile.html#isFile"><tt>TFile.isFile()</tt></a> will return <tt>true</tt> in this case and in fact they are the only methods an application can rely upon to act properly in this situation: Many other methods use a combination of <a href="../apidocs/net/java/truevfs/access/TFile.html#isDirectory"><tt>TFile.isDirectory()</tt></a> and <a href="../apidocs/net/java/truevfs/access/TFile.html#isFile"><tt>TFile.isFile()</tt></a> calls and will show an undefined behavior.</p>
<p>The good news is that both the file and the directory coexist in the virtual archive file system implemented by this package. Thus, whenever the archive file is modified, both entries will be retained and no data gets lost. This enables an application to use another tool to fix the issue in the archive file. TrueVFS does not support to create such an archive file, however.</p></div></div></div>
              </div>
    </div>
    <div class="clear"><hr/></div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2005-2017
                        <a href="http://schlichtherle.de">Schlichtherle IT Services</a>.
            All Rights Reserved.      
                                   <span id="publishDate">Last Published: 2017-09-19</span>
                        </div>
      <div class="clear"><hr/></div>
    </div>
  </body>
</html>
